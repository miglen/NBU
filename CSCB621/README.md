# CSCB621 Програмиране с XML (тест 1)


## За многократна обработка на един и същ XML код с XSLT се използват:
 * __режими (mode)__
 * приоритет (priority)
 * cell-template
 * apply-templates


## В XML документа:

```<books>
<BOOK>
<TITLE>Beginning XML</TITLE>
<AUTHOR>David Hunter</AUTHOR>
<ANOTATION>description</ANOTATION>
<INFO>
<PAGES>1022</PAGES>
<PRICE type=“EURO“>30</PRICE>
</INFO>
<COVER href="wrox_logo.gif"/>
</BOOK>
...........
</books>
```

Опишете XPath пътя до елемента COVER, като започнете от виртуалния корен:
`order[@COVER]`

## Интерфейс базиран на "дърво на данните" се използва от:
Изберете едно
* SAX
* DOM
* StAX
* XSL
* XQuery

## С „.“ в XPath се отбелязва:

 * __текущо обработвания елемент__
 * корена на документа
 * root елемента
 * този символ не се използва
 * XML нотацията

## Коя от XPath осите се използва по премълчаване (не се изписва):

 *  __child__
 * parent
 * self
 * attribute

## XSL включва:
Изберете едно или повече:

 *  __XSLT__
 * __XSL-FO__
 * XML Schema
 * XHTML

## В кой/кои региони на страницата (XSL-FO) може да се постави съдържание?

 *  __във всички__
 * само в region-body
 * само в region-before и region-after
 * само в region-start и region-end

## Достъпа до атрибут „id“ на елемент с XPath израз се осъществява с:

 * attribute::id
 * __@id__
 * ::id
 * /id

## В XSLT възможно ли е предаването на параметри към шаблон?

 * __Да__
 * Не

## <xsl:text> позволява вмъкване в резултатното дърво само на:

 * __PCDATA__
 * шаблон
 * XML код
 * няма ограничения

## XPath оста parent може да се замени от:
 * __..__
 * .
 * /
 * @

## Динамично създаване на елемент и|или атрибут с XSLT е:

 * __възможно__
 * невъзможно

## Отбележете вярното твърдение:

 * XPath 1.0 израза може да се изчислява
 * __root елемента на XML документа е дъщерен на XPath корена__
 * __XPath 1.0 кода трябва да се затваря, подобно на XML елементите__
 * XPath 1.0 израза винаги връща XML елемент


## XSL таблицата се описва в елемент:

 * stylesheet
 * xslt
 * xsl
 * __xsl-table__


## Главния елемент в XSL-FO е:

 * __root__
 * xsl-fo
 * XSL-FO не използва предварително дефинирани имена на елементи
 * stylesheet

## Създаването и използването на потребителски функции е възможно в:

 * __XSLT 1.0__
 * XSLT 2.0

## Коя XPath функция връща името на обработвания възел:
`name(.)`

## XPath се използва в:

 * XLink
 * __XQuery__
 * __XSLT__
 * DTD

## С „/“ в XPath се отбелязва:

 * __корена на документа_
 * root елемента
 * този символ не се използва
 * текущо обработвания елемент
 * XML нотацията

## XSLT елемента <xsl:value-of select=“.“/> извлича:

 * __съдържанието на текущо обработвания възел__
 * името на текущо обработвания възел
 * съдържанието на root елемента
 * съдържанието на целия XML документ

## Кой тип XML база данни използва релационния модел за съхранение и управление на данни.

 * XML Enabled
 * __Native XML__
 * няма такъв тип XML база данни

## За страница в XSL-FO се правят две описания - за структура и за съдържание.

 * __Истина__
 * Неистина

## Кой от езиците не е с XML синтаксис:

 * XQuery
 * __XQueryX__
 * XSL-FO
 * XSLT
 * XML Schema

## За явно извикване на шаблон (по име на шаблона) се използва XSLT команда:
`<xsl:call-template>`
